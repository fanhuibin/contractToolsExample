package com.zhaoxinms.contract.tools.ocr;

import com.zhaoxinms.contract.tools.compare.DiffUtil;
import com.zhaoxinms.contract.tools.ocr.model.CharBox;
import com.zhaoxinms.contract.tools.ocr.model.DiffBlock;

import java.util.*;

/**
 * Diff Processing Utility Class
 *
 * Provides core functionality for text difference analysis and processing,
 * including: - Convert diff objects generated by Google diff-match-patch
 * algorithm to structured DiffBlock objects - Apply custom filtering rules to
 * filter out unwanted difference content - Provide detailed difference analysis
 * and statistics
 *
 * @author zhaoxin
 * @version 1.0
 * @since 2025-01-14
 */
public class DiffProcessingUtil {

	/**
	 * Convert diff list to DiffBlock list
	 *
	 * Convert diff objects to corresponding DiffBlock objects based on diff
	 * operation types (DELETE, INSERT, EQUAL). Each DiffBlock contains
	 * corresponding bbox coordinates, text content and index information.
	 *
	 * @param diffs diff list generated by DiffUtil.diff_main
	 * @param seqA  character sequence of document A
	 * @param seqB  character sequence of document B
	 * @return List of DiffBlock, each representing a difference unit
	 */
	public static List<DiffBlock> splitDiffsByBounding(LinkedList<DiffUtil.Diff> diffs, List<CharBox> seqA,
			List<CharBox> seqB) {
		List<DiffBlock> result = new ArrayList<>();
		DiffBlock prevBlock = null; // 记录上一个block用于设置prevBboxes

		// Pre-calculate: complete text for each bbox in the entire document
		Map<String, StringBuilder> aAllText = new LinkedHashMap<>();
		Map<String, StringBuilder> bAllText = new LinkedHashMap<>();
		for (CharBox c : seqA) {
			if (c.bbox != null) {
				String k = key(c.page, c.bbox);
				aAllText.computeIfAbsent(k, kk -> new StringBuilder()).append(c.ch);
			}
		}
		for (CharBox c : seqB) {
			if (c.bbox != null) {
				String k = key(c.page, c.bbox);
				bAllText.computeIfAbsent(k, kk -> new StringBuilder()).append(c.ch);
			}
		}

		int aIdx = 0, bIdx = 0;
		for (DiffUtil.Diff d : diffs) {
			String txt = d.text.replaceAll("\n", "");
			int len = txt.length();

			List<CharBox> aSeg = Collections.emptyList();
			List<CharBox> bSeg = Collections.emptyList();

			if (d.operation == DiffUtil.Operation.DELETE) {
				int actualLenA = calculateActualLength(seqA, aIdx, len);
				aSeg = subChars(seqA, aIdx, aIdx + actualLenA);
				aIdx += actualLenA;
			} else if (d.operation == DiffUtil.Operation.INSERT) {
				int actualLenB = calculateActualLength(seqB, bIdx, len);
				bSeg = subChars(seqB, bIdx, bIdx + actualLenB);
				bIdx += actualLenB;
			} else if (d.operation == DiffUtil.Operation.EQUAL) {
				// EQUAL operation also needs to handle bbox mapping to ensure correct indexing
				int actualLenA = calculateActualLength(seqA, aIdx, len);
				int actualLenB = calculateActualLength(seqB, bIdx, len);
				aSeg = subChars(seqA, aIdx, aIdx + actualLenA);
				bSeg = subChars(seqB, bIdx, bIdx + actualLenB);
				aIdx += actualLenA;
				bIdx += actualLenB;
			}

			// Create DiffBlock containing all related bboxes for this diff
			Map<String, List<CharBox>> aGroups = groupByBox(aSeg);
			Map<String, List<CharBox>> bGroups = groupByBox(bSeg);

			// Collect bboxes involved in this diff
			List<double[]> oldBboxes = new ArrayList<>();
			List<double[]> newBboxes = new ArrayList<>();
			List<String> allTextAList = new ArrayList<>();
			List<String> allTextBList = new ArrayList<>();
			StringBuilder allOldText = new StringBuilder();
			StringBuilder allNewText = new StringBuilder();
			String category = "";
			int pageA = 1; // Document A page
			int pageB = 1; // Document B page

			// Process aGroups and bGroups separately based on operation type
			if (d.operation == DiffUtil.Operation.DELETE) {
				// DELETE operation: only process bboxes from document A
				for (String k : aGroups.keySet()) {
					List<CharBox> aa = aGroups.get(k);
					if (aa.isEmpty())
						continue;

					double[] bbox;
					try {
						bbox = parseBoxKey(k);
					} catch (IllegalArgumentException e) {
						System.err.println("Warning: Skipping invalid bbox key in splitDiffsByBounding: " + k + " - "
								+ e.getMessage());
						continue;
					}

					String oldText = join(aa);
					oldBboxes.add(bbox);
					allTextAList.add(aAllText.get(k) == null ? "" : aAllText.get(k).toString());
					allOldText.append(oldText);

					if (category.isEmpty()) {
						category = pickCategory(aa, Collections.emptyList());
					}

					if (pageA == 1) {
						pageA = pageOf(aa);
					}
				}

			} else if (d.operation == DiffUtil.Operation.INSERT) {
				// INSERT operation: only process bboxes from document B
				for (String k : bGroups.keySet()) {
					List<CharBox> bb = bGroups.get(k);
					if (bb.isEmpty())
						continue;

					double[] bbox;
					try {
						bbox = parseBoxKey(k);
					} catch (IllegalArgumentException e) {
						System.err.println("Warning: Skipping invalid bbox key in splitDiffsByBounding: " + k + " - "
								+ e.getMessage());
						continue;
					}

					String newText = join(bb);
					newBboxes.add(bbox);
					allTextBList.add(bAllText.get(k) == null ? "" : bAllText.get(k).toString());
					allNewText.append(newText);

					if (category.isEmpty()) {
						category = pickCategory(Collections.emptyList(), bb);
					}

					if (pageB == 1) {
						pageB = pageOf(bb);
					}
				}

			} else if (d.operation == DiffUtil.Operation.EQUAL) {
				// EQUAL operation: process aGroups and bGroups separately to ensure correct
				// bbox correspondence

				// Process all bboxes from document A
				for (String k : aGroups.keySet()) {
					List<CharBox> aa = aGroups.get(k);
					if (aa.isEmpty())
						continue;

					double[] bbox;
					try {
						bbox = parseBoxKey(k);
					} catch (IllegalArgumentException e) {
						System.err.println("Warning: Skipping invalid bbox key in splitDiffsByBounding: " + k + " - "
								+ e.getMessage());
						continue;
					}

					String oldText = join(aa);
					oldBboxes.add(bbox);
					allTextAList.add(aAllText.get(k) == null ? "" : aAllText.get(k).toString());
					allOldText.append(oldText);

					if (category.isEmpty()) {
						category = pickCategory(aa, Collections.emptyList());
					}

					if (pageA == 1) {
						pageA = pageOf(aa);
					}
				}

				// Process all bboxes from document B
				for (String k : bGroups.keySet()) {
					List<CharBox> bb = bGroups.get(k);
					if (bb.isEmpty())
						continue;

					double[] bbox;
					try {
						bbox = parseBoxKey(k);
					} catch (IllegalArgumentException e) {
						System.err.println("Warning: Skipping invalid bbox key in splitDiffsByBounding: " + k + " - "
								+ e.getMessage());
						continue;
					}

					String newText = join(bb);
					newBboxes.add(bbox);
					allTextBList.add(bAllText.get(k) == null ? "" : bAllText.get(k).toString());
					allNewText.append(newText);

					if (category.isEmpty()) {
						category = pickCategory(Collections.emptyList(), bb);
					}

					if (pageB == 1) {
						pageB = pageOf(bb);
					}
				}
			}

			// Set new type based on original diff operation type
			DiffBlock.DiffType dt;
			if (d.operation == DiffUtil.Operation.DELETE) {
				dt = DiffBlock.DiffType.DELETED;
			} else if (d.operation == DiffUtil.Operation.INSERT) {
				dt = DiffBlock.DiffType.ADDED;
			} else if (d.operation == DiffUtil.Operation.EQUAL) {
				dt = DiffBlock.DiffType.IGNORED; // EQUAL operation marked as IGNORED, no need to mark in PDF
			} else {
				continue; // Unknown operation type, skip
			}

			// Create DiffBlock containing oldBboxes and newBboxes
			// textStartIndexA and textStartIndexB are directly set to current diff's
			// starting position aIdx and bIdx in text
			DiffBlock blk = DiffBlock.of(dt, pageA, pageB, oldBboxes, newBboxes, category, allOldText.toString(),
					allNewText.toString(), aIdx, bIdx, d);

			// Set index information directly (simplified logic)
			blk.indexA = (d.operation == DiffUtil.Operation.DELETE || d.operation == DiffUtil.Operation.EQUAL) ? aIdx
					: -1;
			blk.indexB = (d.operation == DiffUtil.Operation.INSERT || d.operation == DiffUtil.Operation.EQUAL) ? bIdx
					: -1;

			blk.allTextA = allTextAList;
			blk.allTextB = allTextBList;
			
			// 计算差异文本在完整文本中的位置范围
			// 只有DELETE操作才计算diffRangesA，只有INSERT操作才计算diffRangesB
			boolean hasDiffA = d.operation == DiffUtil.Operation.DELETE;
			boolean hasDiffB = d.operation == DiffUtil.Operation.INSERT;
			
			System.out.println("计算差异范围调试 - 操作类型: " + d.operation + 
				", hasDiffA: " + hasDiffA + ", hasDiffB: " + hasDiffB);
			System.out.println("allTextA: " + allTextAList + ", oldText: " + allOldText.toString());
			System.out.println("allTextB: " + allTextBList + ", newText: " + allNewText.toString());
			
			blk.diffRangesA = calculateDiffRanges(allTextAList, allOldText.toString(), hasDiffA);
			blk.diffRangesB = calculateDiffRanges(allTextBList, allNewText.toString(), hasDiffB);
			
			System.out.println("计算结果 - diffRangesA: " + blk.diffRangesA + ", diffRangesB: " + blk.diffRangesB);

			// Set previous block's bboxes for synchronization
			if (prevBlock != null) {
				blk.prevOldBboxes = new ArrayList<>(prevBlock.oldBboxes);
				blk.prevNewBboxes = new ArrayList<>(prevBlock.newBboxes);
			}

			result.add(blk);

			// Update previous block reference for next iteration
			prevBlock = blk;
		}
		return result;
	}

	/**
	 * 计算差异文本在完整文本中的位置范围
	 * @param allTextList 完整文本列表（每个bbox对应的完整文本）
	 * @param diffText 差异文本
	 * @param hasDiff 是否有差异（true表示有差异，false表示无差异）
	 * @return 差异文本范围列表
	 */
	private static List<DiffBlock.TextRange> calculateDiffRanges(List<String> allTextList, String diffText, boolean hasDiff) {
		List<DiffBlock.TextRange> ranges = new ArrayList<>();
		
		System.out.println("calculateDiffRanges 调试 - hasDiff: " + hasDiff + 
			", allTextList: " + allTextList + ", diffText: " + diffText);
		
		if (!hasDiff || allTextList == null || allTextList.isEmpty() || diffText == null || diffText.trim().isEmpty()) {
			System.out.println("calculateDiffRanges - 条件不满足，返回空范围");
			return ranges;
		}
		
		int currentPos = 0;
		for (String fullText : allTextList) {
			if (fullText == null || fullText.isEmpty()) {
				currentPos += fullText != null ? fullText.length() : 0;
				continue;
			}
			
			System.out.println("查找差异文本 - 完整文本: '" + fullText + "', 差异文本: '" + diffText.trim() + "'");
			
			// 在完整文本中查找差异文本的位置（输出详细调试信息）
			String dt = diffText.trim();
			int diffStart = fullText.indexOf(dt);
			System.out.println("查找结果 - diffStart: " + diffStart
				+ ", fullText.len=" + fullText.length()
				+ ", diffText.len=" + dt.length()
				+ ", contains=" + fullText.contains(dt)
				+ ", equals=" + fullText.equals(dt));
			// 打印可疑不可见字符（前60字符）
			System.out.println("fullText.head60(codepoints): " + toCodePointsPreview(fullText, 60));
			System.out.println("diffText.head60(codepoints):  " + toCodePointsPreview(dt, 60));
			// 进一步尝试：去掉空白与常见标点后再尝试匹配，仅用于调试输出
			if (diffStart < 0) {
				String normFull = normalizeForSearch(fullText);
				String normDiff = normalizeForSearch(dt);
				int try2 = normFull.indexOf(normDiff);
				System.out.println("二次尝试(去空白标点) - try2.index=" + try2
					+ ", normFull.len=" + normFull.length()
					+ ", normDiff.len=" + normDiff.length());
			}
			
			if (diffStart >= 0) {
				// 找到差异文本，记录范围
				int diffEnd = diffStart + diffText.trim().length();
				ranges.add(new DiffBlock.TextRange(currentPos + diffStart, currentPos + diffEnd, "DIFF"));
				System.out.println("添加范围 - start: " + (currentPos + diffStart) + ", end: " + (currentPos + diffEnd));
			}
			
			currentPos += fullText.length();
		}
		
		System.out.println("calculateDiffRanges 最终结果 - ranges: " + ranges);
		return ranges;
	}

	/**
	 * 将字符串前n个字符输出为 code point 序列，便于定位不可见/相似字符
	 */
	private static String toCodePointsPreview(String s, int maxChars) {
		if (s == null) return "null";
		StringBuilder sb = new StringBuilder();
		int count = 0;
		for (int i = 0; i < s.length() && count < maxChars; ) {
			int cp = s.codePointAt(i);
			if (count > 0) sb.append(' ');
			sb.append(Integer.toHexString(cp));
			i += Character.charCount(cp);
			count++;
		}
		return sb.toString();
	}

	/**
	 * 归一化文本用于调试匹配：去除所有空白、中文全角/半角冒号、顿号、逗号等常见标点差异
	 */
	private static String normalizeForSearch(String s) {
		if (s == null) return "";
		// 去除所有空白
		String t = s.replaceAll("\\s+", "");
		// 统一常见符号（中英文冒号/逗号/顿号/破折号等）
		t = t.replace('：', ':').replace('，', ',').replace('、', ',').replace('；', ';').replace('—', '-');
		return t;
	}

	/**
	 * Filter DiffBlock list according to diff_cleanupCustomIgnore rules
	 *
	 * Simplified filtering method: directly use data from rawBlocks, only apply
	 * filtering rules to mark ignored blocks. Use originalDiff.text content to
	 * determine if block should be ignored. rawBlocks has already calculated
	 * textStartIndexA, textStartIndexB, etc., no need to recalculate.
	 *
	 * @param blocks original DiffBlock list from splitDiffsByBounding method
	 * @param seqA   character sequence of document A
	 * @param seqB   character sequence of document B
	 * @return filtered DiffBlock list containing all differences but marking
	 *         ignored items
	 */
	public static List<DiffBlock> filterIgnoredDiffBlocks(List<DiffBlock> blocks, List<CharBox> seqA,
			List<CharBox> seqB) {
		// Simplified filtering method: directly use originalDiff.text from each block
		// to determine if it should be ignored
		if (blocks.isEmpty())
			return blocks;

		int ignoredCount = 0;
		int retainedCount = 0;

		// Output filtering start information
		System.out.println("=== Difference Filtering Statistics ===");
		System.out.println("Total blocks to process: " + blocks.size());

		// Mark blocks that should be ignored based on their originalDiff.text content
		for (DiffBlock block : blocks) {
			if (block.originalDiff == null) {
				// No original diff information, retain the block
				retainedCount++;
				continue;
			}

			// Check if this block should be ignored based on its text content
			String ignoreReason = getIgnoreReason(block.originalDiff);
			boolean shouldIgnore = !"".equals(ignoreReason); // If there's a reason, it should be ignored

			if (shouldIgnore) {
				block.type = DiffBlock.DiffType.IGNORED;
				ignoredCount++;
//				System.out.println(String.format("Ignored block: Operation=%s, Text='%s' (Length=%d) -> Reason: %s",
//						block.originalDiff.operation.name(), block.originalDiff.text.replace("\n", "\\n"),
//						block.originalDiff.text.length(), ignoreReason));
			} else {
				retainedCount++;
			}
		}

		// Output final filtering statistics
//		System.out.println("Filtering completed: Retained=" + retainedCount + ", Ignored=" + ignoredCount + ", Total="
//				+ blocks.size());

		return blocks;
	}

	// Auxiliary methods: copied from DotsOcrCompareDemoTest
	private static String key(int page, double[] box) {
		return page + "|" + (int) box[0] + "," + (int) box[1] + "," + (int) box[2] + "," + (int) box[3];
	}

	private static double[] parseBoxKey(String key) {
		String[] parts = key.split("\\|");
		if (parts.length != 2) {
			throw new IllegalArgumentException("Invalid bbox key format: " + key);
		}

		String[] coords = parts[1].split(",");
		if (coords.length != 4) {
			throw new IllegalArgumentException("Invalid bbox coordinates: " + parts[1]);
		}

		return new double[] { Double.parseDouble(coords[0]), Double.parseDouble(coords[1]),
				Double.parseDouble(coords[2]), Double.parseDouble(coords[3]) };
	}

	private static List<CharBox> subChars(List<CharBox> seq, int start, int end) {
		if (start >= seq.size())
			return Collections.emptyList();
		end = Math.min(end, seq.size());
		return seq.subList(start, end);
	}

	private static Map<String, List<CharBox>> groupByBox(List<CharBox> chars) {
		Map<String, List<CharBox>> groups = new LinkedHashMap<>();
		for (CharBox c : chars) {
			if (c.bbox != null) {
				String key = key(c.page, c.bbox);
				groups.computeIfAbsent(key, k -> new ArrayList<>()).add(c);
			}
		}
		return groups;
	}

	private static String join(List<CharBox> chars) {
		StringBuilder sb = new StringBuilder();
		for (CharBox c : chars) {
			sb.append(c.ch);
		}
		return sb.toString();
	}

	private static int pageOf(List<CharBox> chars) {
		if (chars.isEmpty())
			return 1;
		return chars.get(0).page;
	}

	private static String pickCategory(List<CharBox> a, List<CharBox> b) {
		List<CharBox> chars = !a.isEmpty() ? a : b;
		if (chars.isEmpty())
			return "unknown";

		// Simple classification logic: check character types
		boolean hasDigits = false;
		boolean hasLetters = false;
		boolean hasSymbols = false;

		for (CharBox c : chars) {
			char ch = c.ch;
			if (Character.isDigit(ch)) {
				hasDigits = true;
			} else if (Character.isLetter(ch)) {
				hasLetters = true;
			} else if (!Character.isWhitespace(ch)) {
				hasSymbols = true;
			}
		}

		if (hasDigits && !hasLetters && !hasSymbols)
			return "digits";
		if (hasLetters && !hasDigits && !hasSymbols)
			return "letters";
		if (hasSymbols && !hasDigits && !hasLetters)
			return "symbols";
		return "mixed";
	}

	/**
	 * 分析差异被忽略的原因 - 参考diff_cleanupCustomIgnore的完整实现逻辑
	 */
	private static String getIgnoreReason(DiffUtil.Diff diff) {
		// 处理空文本
		if (diff.text == null || diff.text.isEmpty()) {
			return "空文本";
		}

		// 第一阶段：检查是否是需要完全过滤的内容类型
		if (isAllSpaces(diff.text)) {
			return "全为空格字符";
		}

		if (isAllUnderscores(diff.text)) {
			return "全为下划线字符";
		}

		if (isAllSpacesOrUnderscores(diff.text)) {
			return "空格和下划线混合";
		}

		if (isAllSpacesUnderscoresNewlines(diff.text)) {
			return "包含空格、下划线和换行符";
		}

		// 第二阶段：检查是否为目标标点符号（可能与相邻差异配对过滤）
		if (isTargetPunct(diff.text)) {
			return "单个标点符号（可能与相邻差异配对过滤）";
		}

		// 检查是否为纯数字
//		if (isPureDigits(diff.text)) {
//			return "纯数字";
//		}

		// 检查是否为常见的格式化字符
		if (isFormattingChars(diff.text)) {
			return "格式化字符";
		}

		// 检查是否只包含空格和句号
		if (isSpacesAndDots(diff.text)) {
			return "空格和句号混合";
		}

		// 检查是否全为#号
		if (isAllHashes(diff.text)) {
			return "全为#号字符";
		}

		// 检查是否只包含#号和空格
		if (isHashesAndSpaces(diff.text)) {
			return "#号和空格混合";
		}

		// 检查是否只包含#号和句号
		if (isHashesAndDots(diff.text)) {
			return "#号和句号混合";
		}

		// 如果不是上述情况，但操作是EQUAL，说明是相等内容
		if (diff.operation == DiffUtil.Operation.EQUAL) {
			return "相等内容，无需处理";
		}

		return "";
	}

	/**
	 * 检查字符串是否全为空格
	 */
	private static boolean isAllSpaces(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != ' ')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否全为下划线
	 */
	private static boolean isAllUnderscores(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != '_')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否只包含空格和下划线
	 */
	private static boolean isAllSpacesOrUnderscores(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != ' ' && c != '_')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否只包含空格、下划线和换行符
	 */
	private static boolean isAllSpacesUnderscoresNewlines(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != ' ' && c != '_' && c != '\n' && c != '\r')
				return false;
		}
		return true;
	}

	/**
	 * 检查是否为目标标点符号（支持配对过滤）
	 */
	private static boolean isTargetPunct(String s) {
		if (s == null || s.length() != 1)
			return false;
		char c = s.charAt(0);
		return c == ',' || c == '、' || c == '.';
	}

	/**
	 * 检查是否为纯数字
	 */
	private static boolean isPureDigits(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (!Character.isDigit(s.charAt(i)))
				return false;
		}
		return true;
	}

	/**
	 * 检查是否为常见的格式化字符
	 */
	private static boolean isFormattingChars(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			// 常见的格式化字符：制表符、换页符等
			if (c != '\t' && c != '\f' && c != '\u00A0' && c != '\u2007' && c != '\u202F') {
				return false;
			}
		}
		return true;
	}

	/**
	 * 检查字符串是否只包含空格和句号
	 */
	private static boolean isSpacesAndDots(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != ' ' && c != '.')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否全为#号
	 */
	private static boolean isAllHashes(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != '#')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否只包含#号和空格
	 */
	private static boolean isHashesAndSpaces(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != '#' && c != ' ')
				return false;
		}
		return true;
	}

	/**
	 * 检查字符串是否只包含#号和句号
	 */
	private static boolean isHashesAndDots(String s) {
		if (s == null || s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (c != '#' && c != '.')
				return false;
		}
		return true;
	}

	/**
	 * 计算CharBox片段的实际长度，包括所有换行符 用于处理diff文本中换行符被移除但CharBox中仍然存在的情况 逐步增加长度，每次只处理新增的换行符
	 *
	 * @param fullSequence 完整的CharBox序列
	 * @param startIndex   起始索引
	 * @param baseLength   基础长度（移除换行符后的文本长度）
	 * @return 实际需要的长度
	 */
	private static int calculateActualLength(List<CharBox> fullSequence, int startIndex, int baseLength) {
		int currentLength = baseLength;
		int maxIterations = 100; // 防止无限循环
		int iteration = 0;

		while (iteration < maxIterations) {
			// 基于当前长度获取segment
			List<CharBox> segment = subChars(fullSequence, startIndex, startIndex + currentLength);

			// 如果segment为空，直接返回当前长度
			if (segment == null || segment.isEmpty()) {
				return currentLength;
			}

			// 检查segment是否包含换行符
			boolean hasNewlines = segment.stream().anyMatch(cb -> cb.ch == '\n');

			if (!hasNewlines) {
				// 没有换行符，当前长度就是实际长度
				return currentLength;
			}

			if (iteration == 0) {
				long count = segment.stream().filter(cb -> cb.ch == '\n').count();

				currentLength += count;
			} else {
				// 判断增加的是不是'\n'
				if (segment.get(segment.size() - 1).ch == '\n') {
					currentLength += 1;
				} else {
					return currentLength;
				}
			}
			iteration++;
		}

		// 如果达到最大迭代次数，返回当前长度
		System.err.println("Warning: Reached maximum iterations in calculateActualLength, length=" + currentLength);
		return currentLength;
	}
}
